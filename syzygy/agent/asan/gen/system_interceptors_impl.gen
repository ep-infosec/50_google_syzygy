// Copyright 2017 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is generated by system_interceptor_generator.py, DO NOT MODIFY.
// Regenerate this file by running syzygy/agent/asan/generate_files.bat.

BOOL WINAPI asan_ReadFile(
    _In_ HANDLE hFile,
    _Out_writes_bytes_to_opt_(nNumberOfBytesToRead, *lpNumberOfBytesRead)
        __out_data_source(FILE) LPVOID lpBuffer,
    _In_ DWORD nNumberOfBytesToRead,
    _Out_opt_ LPDWORD lpNumberOfBytesRead,
    _Inout_opt_ LPOVERLAPPED lpOverlapped
    ) {
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToRead,
        agent::asan::ASAN_WRITE_ACCESS);
  }

  
  if (lpNumberOfBytesRead != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpNumberOfBytesRead)),
        sizeof(*lpNumberOfBytesRead),
        agent::asan::ASAN_WRITE_ACCESS);
  }

  if (lpOverlapped != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpOverlapped)),
        sizeof(*lpOverlapped),
        agent::asan::ASAN_READ_ACCESS);
  }


  BOOL ret = 0;
  __try {
    ret = ::ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  if (lpNumberOfBytesRead != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpNumberOfBytesRead)),
        sizeof(*lpNumberOfBytesRead),
        agent::asan::ASAN_WRITE_ACCESS);
  }

  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToRead,
        agent::asan::ASAN_WRITE_ACCESS);
  }


  return ret;
}

BOOL WINAPI asan_ReadFileEx(
    _In_ HANDLE hFile,
    _Out_writes_bytes_opt_(nNumberOfBytesToRead)
        __out_data_source(FILE) LPVOID lpBuffer,
    _In_ DWORD nNumberOfBytesToRead,
    _Inout_ LPOVERLAPPED lpOverlapped,
    _In_opt_ LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    ) {
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToRead,
        agent::asan::ASAN_WRITE_ACCESS);
  }

  
  if (lpOverlapped != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpOverlapped)),
        sizeof(*lpOverlapped),
        agent::asan::ASAN_READ_ACCESS);
  }


  BOOL ret = 0;
  __try {
    ret = ::ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToRead,
        agent::asan::ASAN_WRITE_ACCESS);
  }


  return ret;
}

BOOL WINAPI asan_WriteFile(
    _In_ HANDLE hFile,
    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    _In_ DWORD nNumberOfBytesToWrite,
    _Out_opt_ LPDWORD lpNumberOfBytesWritten,
    _Inout_opt_ LPOVERLAPPED lpOverlapped
    ) {
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToWrite,
        agent::asan::ASAN_READ_ACCESS);
  }

  
  if (lpNumberOfBytesWritten != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpNumberOfBytesWritten)),
        sizeof(*lpNumberOfBytesWritten),
        agent::asan::ASAN_WRITE_ACCESS);
  }

  if (lpOverlapped != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpOverlapped)),
        sizeof(*lpOverlapped),
        agent::asan::ASAN_READ_ACCESS);
  }


  BOOL ret = 0;
  __try {
    ret = ::WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  if (lpNumberOfBytesWritten != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpNumberOfBytesWritten)),
        sizeof(*lpNumberOfBytesWritten),
        agent::asan::ASAN_WRITE_ACCESS);
  }

  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToWrite,
        agent::asan::ASAN_READ_ACCESS);
  }


  return ret;
}

BOOL WINAPI asan_WriteFileEx(
    _In_ HANDLE hFile,
    _In_reads_bytes_opt_(nNumberOfBytesToWrite) LPCVOID lpBuffer,
    _In_ DWORD nNumberOfBytesToWrite,
    _Inout_ LPOVERLAPPED lpOverlapped,
    _In_opt_ LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    ) {
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToWrite,
        agent::asan::ASAN_READ_ACCESS);
  }

  
  if (lpOverlapped != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpOverlapped)),
        sizeof(*lpOverlapped),
        agent::asan::ASAN_READ_ACCESS);
  }


  BOOL ret = 0;
  __try {
    ret = ::WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  
  if (lpBuffer != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpBuffer)),
        nNumberOfBytesToWrite,
        agent::asan::ASAN_READ_ACCESS);
  }


  return ret;
}

long WINAPI asan_InterlockedCompareExchange(
    _Inout_ long volatile* Destination,
    _In_ long Exchange,
    _In_ long Comperand
    ) {
  
  
  if (Destination != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t volatile*>(Destination)),
        sizeof(*Destination),
        agent::asan::ASAN_READ_ACCESS);
  }


  long ret = 0;
  __try {
    ret = ::InterlockedCompareExchange(Destination, Exchange, Comperand);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  

  return ret;
}

long WINAPI asan_InterlockedIncrement(
    _Inout_ long* lpAddend
    ) {
  
  
  if (lpAddend != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpAddend)),
        sizeof(*lpAddend),
        agent::asan::ASAN_READ_ACCESS);
  }


  long ret = 0;
  __try {
    ret = ::InterlockedIncrement(lpAddend);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  

  return ret;
}

long WINAPI asan_InterlockedDecrement(
    _Inout_ long* lpAddend
    ) {
  
  
  if (lpAddend != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t *>(lpAddend)),
        sizeof(*lpAddend),
        agent::asan::ASAN_READ_ACCESS);
  }


  long ret = 0;
  __try {
    ret = ::InterlockedDecrement(lpAddend);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  

  return ret;
}

long WINAPI asan_InterlockedExchange(
    _Inout_ _Interlocked_operand_ long volatile* Target,
    _In_ long Value
    ) {
  
  
  if (Target != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t volatile*>(Target)),
        sizeof(*Target),
        agent::asan::ASAN_READ_ACCESS);
  }


  long ret = 0;
  __try {
    ret = ::InterlockedExchange(Target, Value);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  

  return ret;
}

long WINAPI asan_InterlockedExchangeAdd(
    _Inout_ _Interlocked_operand_ long volatile* Addend,
    _In_ long Value
    ) {
  
  
  if (Addend != NULL) {
    TestMemoryRange(
        system_interceptor_shadow_,
        const_cast<const uint8_t*>(reinterpret_cast<
            const uint8_t volatile*>(Addend)),
        sizeof(*Addend),
        agent::asan::ASAN_READ_ACCESS);
  }


  long ret = 0;
  __try {
    ret = ::InterlockedExchangeAdd(Addend, Value);
  } __except (agent::asan::AsanRuntime::CrashForException(
                  GetExceptionInformation())) {
  }

  if (interceptor_tail_callback != NULL)
    (*interceptor_tail_callback)();

  
  

  return ret;
}
