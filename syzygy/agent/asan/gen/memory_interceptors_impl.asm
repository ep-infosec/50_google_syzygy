; Copyright 2017 Google Inc. All Rights Reserved.
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.

; This file is generated by generate_memory_interceptors.py, DO NOT MODIFY.
; Regenerate this file by running syzygy/agent/asan/generate_files.bat.

.386
.MODEL FLAT, C

.CODE

; Allow section and label names to begin with a leading period.
OPTION DOTNAME

; Declare the global shadow memory array that probes refer to.
EXTERN C asan_memory_interceptors_shadow_memory:FAR

; Declare the string checking helper function.
EXTERN C asan_check_strings_memory_accesses:PROC

; Declare the redirect function.
EXTERN C asan_redirect_stub_entry:PROC
EXTERN C asan_redirect_clang_stub_entry:PROC

; Declare the error handling funtion.
EXTERN C asan_report_bad_memory_access:PROC

; Declares the symbols that this compiland exports.
PUBLIC asan_no_check
PUBLIC asan_string_no_check
PUBLIC asan_redirect_tail
PUBLIC asan_redirect_tail_clang
PUBLIC asan_shadow_references
PUBLIC asan_check_1_byte_read_access_2gb  ; Probe #0.
PUBLIC asan_check_1_byte_write_access_2gb  ; Probe #1.
PUBLIC asan_check_2_byte_read_access_2gb  ; Probe #2.
PUBLIC asan_check_2_byte_write_access_2gb  ; Probe #3.
PUBLIC asan_check_4_byte_read_access_2gb  ; Probe #4.
PUBLIC asan_check_4_byte_write_access_2gb  ; Probe #5.
PUBLIC asan_check_8_byte_read_access_2gb  ; Probe #6.
PUBLIC asan_check_8_byte_write_access_2gb  ; Probe #7.
PUBLIC asan_check_10_byte_read_access_2gb  ; Probe #8.
PUBLIC asan_check_10_byte_write_access_2gb  ; Probe #9.
PUBLIC asan_check_16_byte_read_access_2gb  ; Probe #10.
PUBLIC asan_check_16_byte_write_access_2gb  ; Probe #11.
PUBLIC asan_check_32_byte_read_access_2gb  ; Probe #12.
PUBLIC asan_check_32_byte_write_access_2gb  ; Probe #13.
PUBLIC asan_check_1_byte_read_access_no_flags_2gb  ; Probe #14.
PUBLIC asan_check_1_byte_write_access_no_flags_2gb  ; Probe #15.
PUBLIC asan_check_2_byte_read_access_no_flags_2gb  ; Probe #16.
PUBLIC asan_check_2_byte_write_access_no_flags_2gb  ; Probe #17.
PUBLIC asan_check_4_byte_read_access_no_flags_2gb  ; Probe #18.
PUBLIC asan_check_4_byte_write_access_no_flags_2gb  ; Probe #19.
PUBLIC asan_check_8_byte_read_access_no_flags_2gb  ; Probe #20.
PUBLIC asan_check_8_byte_write_access_no_flags_2gb  ; Probe #21.
PUBLIC asan_check_10_byte_read_access_no_flags_2gb  ; Probe #22.
PUBLIC asan_check_10_byte_write_access_no_flags_2gb  ; Probe #23.
PUBLIC asan_check_16_byte_read_access_no_flags_2gb  ; Probe #24.
PUBLIC asan_check_16_byte_write_access_no_flags_2gb  ; Probe #25.
PUBLIC asan_check_32_byte_read_access_no_flags_2gb  ; Probe #26.
PUBLIC asan_check_32_byte_write_access_no_flags_2gb  ; Probe #27.
PUBLIC asan_check_1_byte_read_access_4gb  ; Probe #28.
PUBLIC asan_check_1_byte_write_access_4gb  ; Probe #29.
PUBLIC asan_check_2_byte_read_access_4gb  ; Probe #30.
PUBLIC asan_check_2_byte_write_access_4gb  ; Probe #31.
PUBLIC asan_check_4_byte_read_access_4gb  ; Probe #32.
PUBLIC asan_check_4_byte_write_access_4gb  ; Probe #33.
PUBLIC asan_check_8_byte_read_access_4gb  ; Probe #34.
PUBLIC asan_check_8_byte_write_access_4gb  ; Probe #35.
PUBLIC asan_check_10_byte_read_access_4gb  ; Probe #36.
PUBLIC asan_check_10_byte_write_access_4gb  ; Probe #37.
PUBLIC asan_check_16_byte_read_access_4gb  ; Probe #38.
PUBLIC asan_check_16_byte_write_access_4gb  ; Probe #39.
PUBLIC asan_check_32_byte_read_access_4gb  ; Probe #40.
PUBLIC asan_check_32_byte_write_access_4gb  ; Probe #41.
PUBLIC asan_check_1_byte_read_access_no_flags_4gb  ; Probe #42.
PUBLIC asan_check_1_byte_write_access_no_flags_4gb  ; Probe #43.
PUBLIC asan_check_2_byte_read_access_no_flags_4gb  ; Probe #44.
PUBLIC asan_check_2_byte_write_access_no_flags_4gb  ; Probe #45.
PUBLIC asan_check_4_byte_read_access_no_flags_4gb  ; Probe #46.
PUBLIC asan_check_4_byte_write_access_no_flags_4gb  ; Probe #47.
PUBLIC asan_check_8_byte_read_access_no_flags_4gb  ; Probe #48.
PUBLIC asan_check_8_byte_write_access_no_flags_4gb  ; Probe #49.
PUBLIC asan_check_10_byte_read_access_no_flags_4gb  ; Probe #50.
PUBLIC asan_check_10_byte_write_access_no_flags_4gb  ; Probe #51.
PUBLIC asan_check_16_byte_read_access_no_flags_4gb  ; Probe #52.
PUBLIC asan_check_16_byte_write_access_no_flags_4gb  ; Probe #53.
PUBLIC asan_check_32_byte_read_access_no_flags_4gb  ; Probe #54.
PUBLIC asan_check_32_byte_write_access_no_flags_4gb  ; Probe #55.
PUBLIC asan_check_repz_4_byte_cmps_access  ; Probe #56.
PUBLIC asan_check_repz_2_byte_cmps_access  ; Probe #57.
PUBLIC asan_check_repz_1_byte_cmps_access  ; Probe #58.
PUBLIC asan_check_4_byte_cmps_access  ; Probe #59.
PUBLIC asan_check_2_byte_cmps_access  ; Probe #60.
PUBLIC asan_check_1_byte_cmps_access  ; Probe #61.
PUBLIC asan_check_repz_4_byte_lods_access  ; Probe #62.
PUBLIC asan_check_repz_2_byte_lods_access  ; Probe #63.
PUBLIC asan_check_repz_1_byte_lods_access  ; Probe #64.
PUBLIC asan_check_4_byte_lods_access  ; Probe #65.
PUBLIC asan_check_2_byte_lods_access  ; Probe #66.
PUBLIC asan_check_1_byte_lods_access  ; Probe #67.
PUBLIC asan_check_repz_4_byte_movs_access  ; Probe #68.
PUBLIC asan_check_repz_2_byte_movs_access  ; Probe #69.
PUBLIC asan_check_repz_1_byte_movs_access  ; Probe #70.
PUBLIC asan_check_4_byte_movs_access  ; Probe #71.
PUBLIC asan_check_2_byte_movs_access  ; Probe #72.
PUBLIC asan_check_1_byte_movs_access  ; Probe #73.
PUBLIC asan_check_repz_4_byte_stos_access  ; Probe #74.
PUBLIC asan_check_repz_2_byte_stos_access  ; Probe #75.
PUBLIC asan_check_repz_1_byte_stos_access  ; Probe #76.
PUBLIC asan_check_4_byte_stos_access  ; Probe #77.
PUBLIC asan_check_2_byte_stos_access  ; Probe #78.
PUBLIC asan_check_1_byte_stos_access  ; Probe #79.

; Create a new text segment to house the memory interceptors.
.probes SEGMENT PAGE PUBLIC READ EXECUTE 'CODE'

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_no_check PROC
  ; Restore EDX.
  mov edx, DWORD PTR[esp + 4]
  ; And return.
  ret 4
asan_no_check ENDP

; No state is saved for string instructions.
ALIGN 16
asan_string_no_check PROC
  ; Just return.
  ret
asan_string_no_check ENDP

; On entry, the address to check is in EDX and the stack has:
; - previous contents of EDX.
; - return address to original caller.
; - return address to redirection stub.
ALIGN 16
asan_redirect_tail PROC
  ; Prologue, save context.
  pushfd
  pushad

  ; Normalize the string operation direction.
  cld

  ; Compute the address of the calling function and push it.
  mov eax, DWORD PTR[esp + 9 * 4]
  sub eax, 5  ; Length of call instruction.
  push eax
  ; Push the original caller's address.
  push DWORD PTR[esp + 11 * 4]
  call asan_redirect_stub_entry
  ; Clean arguments off the stack.
  add esp, 8

  ; Overwrite access_size with the stub to return to.
  mov DWORD PTR[esp + 9 * 4], eax

  ; Restore context.
  popad
  popfd

  ; return to the stashed stub.
  ret
asan_redirect_tail ENDP


; On entry the stack has:
; - the address to check.
; - return address to original caller.
; - return address to redirection stub.
ALIGN 16
asan_redirect_tail_clang PROC
  ; Prologue, save context.
  pushfd
  pushad

  ; Normalize the string operation direction.
  cld

  ; Compute the address of the calling function and push it.
  mov eax, DWORD PTR[esp + 9 * 4]
  sub eax, 5  ; Length of call instruction.
  push eax
  ; Push the original caller's address.
  push DWORD PTR[esp + 11 * 4]
  call asan_redirect_clang_stub_entry
  ; Clean arguments off the stack.
  add esp, 8

  ; Overwrite access_size with the stub to return to.
  mov DWORD PTR[esp + 9 * 4], eax

  ; Restore context.
  popad
  popfd

  ; return to the stashed stub.
  ret
asan_redirect_tail_clang ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_read_access_2gb PROC  ; Probe #0.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_0
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_0 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_0
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_0 LABEL NEAR
  js report_failure_0
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_0
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_0 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_write_access_2gb PROC  ; Probe #1.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_1
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_1 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_1
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_1 LABEL NEAR
  js report_failure_1
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_1
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_1 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_read_access_2gb PROC  ; Probe #2.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_2
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_2 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_2
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_2 LABEL NEAR
  js report_failure_2
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_2
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_2 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_write_access_2gb PROC  ; Probe #3.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_3 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_3
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_3 LABEL NEAR
  js report_failure_3
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_3
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_3 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_read_access_2gb PROC  ; Probe #4.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_4
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_4 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_4
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_4 LABEL NEAR
  js report_failure_4
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_4
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_4 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_write_access_2gb PROC  ; Probe #5.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_5
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_5 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_5
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_5 LABEL NEAR
  js report_failure_5
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_5
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_5 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_read_access_2gb PROC  ; Probe #6.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_6
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_6 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_6
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_6 LABEL NEAR
  js report_failure_6
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_6
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_6 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_write_access_2gb PROC  ; Probe #7.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_7
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_7 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_7
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_7 LABEL NEAR
  js report_failure_7
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_7
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_7 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_read_access_2gb PROC  ; Probe #8.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_8
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_8 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_8
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_8 LABEL NEAR
  js report_failure_8
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_8
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_8 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_write_access_2gb PROC  ; Probe #9.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_9
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_9 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_9
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_9 LABEL NEAR
  js report_failure_9
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_9
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_9 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_read_access_2gb PROC  ; Probe #10.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_10
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_10 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_10
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_10 LABEL NEAR
  js report_failure_10
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_10
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_10 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_write_access_2gb PROC  ; Probe #11.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_11
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_11 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_11
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_11 LABEL NEAR
  js report_failure_11
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_11
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_11 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_read_access_2gb PROC  ; Probe #12.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_12
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_12 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_12
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_12 LABEL NEAR
  js report_failure_12
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_12
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_12 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_write_access_2gb PROC  ; Probe #13.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_13
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_13 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_13
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_13 LABEL NEAR
  js report_failure_13
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_13
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_13 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_read_access_no_flags_2gb PROC  ; Probe #14.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_14
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_14 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_14
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_14 LABEL NEAR
  js report_failure_14
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_14
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_14 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_write_access_no_flags_2gb PROC  ; Probe #15.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_15
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_15 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_15
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_15 LABEL NEAR
  js report_failure_15
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_15
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_15 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_read_access_no_flags_2gb PROC  ; Probe #16.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_16
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_16 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_16
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_16 LABEL NEAR
  js report_failure_16
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_16
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_16 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_write_access_no_flags_2gb PROC  ; Probe #17.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_17
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_17 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_17
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_17 LABEL NEAR
  js report_failure_17
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_17
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_17 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_read_access_no_flags_2gb PROC  ; Probe #18.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_18
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_18 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_18
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_18 LABEL NEAR
  js report_failure_18
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_18
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_18 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_write_access_no_flags_2gb PROC  ; Probe #19.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_19
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_19 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_19
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_19 LABEL NEAR
  js report_failure_19
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_19
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_19 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_read_access_no_flags_2gb PROC  ; Probe #20.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_20
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_20 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_20
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_20 LABEL NEAR
  js report_failure_20
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_20
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_20 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_write_access_no_flags_2gb PROC  ; Probe #21.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_21
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_21 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_21
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_21 LABEL NEAR
  js report_failure_21
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_21
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_21 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_read_access_no_flags_2gb PROC  ; Probe #22.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_22
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_22 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_22
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_22 LABEL NEAR
  js report_failure_22
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_22
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_22 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_write_access_no_flags_2gb PROC  ; Probe #23.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_23
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_23 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_23
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_23 LABEL NEAR
  js report_failure_23
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_23
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_23 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_read_access_no_flags_2gb PROC  ; Probe #24.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_24
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_24 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_24
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_24 LABEL NEAR
  js report_failure_24
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_24
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_24 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_write_access_no_flags_2gb PROC  ; Probe #25.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_25
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_25 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_25
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_25 LABEL NEAR
  js report_failure_25
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_25
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_25 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_read_access_no_flags_2gb PROC  ; Probe #26.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_26
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_26 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_26
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_26 LABEL NEAR
  js report_failure_26
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_26
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_26 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_write_access_no_flags_2gb PROC  ; Probe #27.
  push edx
  ; Divide by 8 to convert the address to a shadow index. This is a signed
  ; operation so the sign bit will stay positive if the address is above the 2GB
  ; threshold, and the check will fail.
  sar edx, 3
  js report_failure_27
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_27 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_27
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_27 LABEL NEAR
  js report_failure_27
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_27
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_27 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access_no_flags_2gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_read_access_4gb PROC  ; Probe #28.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_28 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_28
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_28 LABEL NEAR
  js report_failure_28
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_28
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_28 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_1_byte_write_access_4gb PROC  ; Probe #29.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_29 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_29
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_29 LABEL NEAR
  js report_failure_29
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_29
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_29 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_read_access_4gb PROC  ; Probe #30.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_30 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_30
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_30 LABEL NEAR
  js report_failure_30
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_30
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_30 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_2_byte_write_access_4gb PROC  ; Probe #31.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_31 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_31
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_31 LABEL NEAR
  js report_failure_31
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_31
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_31 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_read_access_4gb PROC  ; Probe #32.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_32 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_32
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_32 LABEL NEAR
  js report_failure_32
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_32
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_32 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_4_byte_write_access_4gb PROC  ; Probe #33.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_33 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_33
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_33 LABEL NEAR
  js report_failure_33
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_33
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_33 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_read_access_4gb PROC  ; Probe #34.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_34 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_34
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_34 LABEL NEAR
  js report_failure_34
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_34
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_34 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_8_byte_write_access_4gb PROC  ; Probe #35.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_35 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_35
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_35 LABEL NEAR
  js report_failure_35
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_35
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_35 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_read_access_4gb PROC  ; Probe #36.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_36 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_36
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_36 LABEL NEAR
  js report_failure_36
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_36
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_36 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_10_byte_write_access_4gb PROC  ; Probe #37.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_37 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_37
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_37 LABEL NEAR
  js report_failure_37
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_37
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_37 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_read_access_4gb PROC  ; Probe #38.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_38 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_38
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_38 LABEL NEAR
  js report_failure_38
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_38
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_38 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_16_byte_write_access_4gb PROC  ; Probe #39.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_39 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_39
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_39 LABEL NEAR
  js report_failure_39
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_39
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_39 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_read_access_4gb PROC  ; Probe #40.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_40 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_40
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_40 LABEL NEAR
  js report_failure_40
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_40
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_40 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function modifies no other registers,
; in particular it saves and restores EFLAGS.
ALIGN 16
asan_check_32_byte_write_access_4gb PROC  ; Probe #41.
  ; Save the EFLAGS.
  push eax
  lahf
  seto al
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_41 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_41
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
check_access_slow_41 LABEL NEAR
  js report_failure_41
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_41
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 8]
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ret 4
report_failure_41 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore the EFLAGS.
  add al, 7Fh
  sahf
  pop eax
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_read_access_no_flags_4gb PROC  ; Probe #42.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_42 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_42
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_42 LABEL NEAR
  js report_failure_42
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_42
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_42 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_1_byte_write_access_no_flags_4gb PROC  ; Probe #43.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_43 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_43
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_43 LABEL NEAR
  js report_failure_43
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_43
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_43 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 1
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_1_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_read_access_no_flags_4gb PROC  ; Probe #44.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_44 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_44
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_44 LABEL NEAR
  js report_failure_44
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_44
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_44 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_2_byte_write_access_no_flags_4gb PROC  ; Probe #45.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_45 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_45
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_45 LABEL NEAR
  js report_failure_45
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_45
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_45 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 2
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_2_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_read_access_no_flags_4gb PROC  ; Probe #46.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_46 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_46
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_46 LABEL NEAR
  js report_failure_46
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_46
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_46 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_4_byte_write_access_no_flags_4gb PROC  ; Probe #47.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_47 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_47
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_47 LABEL NEAR
  js report_failure_47
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_47
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_47 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 4
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_4_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_read_access_no_flags_4gb PROC  ; Probe #48.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_48 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_48
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_48 LABEL NEAR
  js report_failure_48
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_48
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_48 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_8_byte_write_access_no_flags_4gb PROC  ; Probe #49.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_49 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_49
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_49 LABEL NEAR
  js report_failure_49
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_49
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_49 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 8
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_8_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_read_access_no_flags_4gb PROC  ; Probe #50.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_50 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_50
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_50 LABEL NEAR
  js report_failure_50
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_50
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_50 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_10_byte_write_access_no_flags_4gb PROC  ; Probe #51.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_51 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_51
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_51 LABEL NEAR
  js report_failure_51
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_51
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_51 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 10
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_10_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_read_access_no_flags_4gb PROC  ; Probe #52.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_52 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_52
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_52 LABEL NEAR
  js report_failure_52
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_52
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_52 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_16_byte_write_access_no_flags_4gb PROC  ; Probe #53.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_53 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_53
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_53 LABEL NEAR
  js report_failure_53
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_53
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_53 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 16
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_16_byte_write_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_read_access_no_flags_4gb PROC  ; Probe #54.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_54 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_54
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_54 LABEL NEAR
  js report_failure_54
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_54
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_54 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 0
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_read_access_no_flags_4gb ENDP

; On entry, the address to check is in EDX and the previous contents of
; EDX are on stack. On exit the previous contents of EDX have been restored
; and popped off the stack. This function may modify EFLAGS, but preserves
; all other registers.
ALIGN 16
asan_check_32_byte_write_access_no_flags_4gb PROC  ; Probe #55.
  push edx
  ; Divide by 8 to convert the address to a shadow index. No range check is
  ; needed as the address space is 4GB.
  shr edx, 3
  movzx edx, BYTE PTR[edx + asan_memory_interceptors_shadow_memory]
  ; This is a label to the previous shadow memory reference. It will be
  ; referenced by the table at the end of the 'asan_probes' procedure.
shadow_reference_55 LABEL NEAR
  cmp dl, 0
  jnz check_access_slow_55
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
check_access_slow_55 LABEL NEAR
  js report_failure_55
  mov dh, BYTE PTR[esp]
  and dh, 7
  cmp dh, dl
  jae report_failure_55
  add esp, 4
  ; Restore original EDX.
  mov edx, DWORD PTR[esp + 4]
  ret 4
report_failure_55 LABEL NEAR
  ; Restore memory location in EDX.
  pop edx
  ; Restore original value of EDX, and put memory location on stack.
  xchg edx, DWORD PTR[esp + 4]
  ; Create an Asan registers context on the stack.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 12 bytes (e.g. EFLAGS / EIP / Original EDX).
  add DWORD PTR[esp + 12], 12
  ; Push ARG4: the address of Asan context on stack.
  push esp
  ; Push ARG3: the access size.
  push 32
  ; Push ARG2: the access type.
  push 1
  ; Push ARG1: the memory location.
  push DWORD PTR[esp + 52]
  call asan_report_bad_memory_access
  ; Remove 4 x ARG on stack.
  add esp, 16
  ; Restore original registers.
  popad
  popfd
  ; Return and remove memory location on stack.
  ret 4
asan_check_32_byte_write_access_no_flags_4gb ENDP

ALIGN 16
asan_check_repz_4_byte_cmps_access PROC  ; Probe #56.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_56
  neg ebx
skip_neg_direction_56 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_2_byte_cmps_access PROC  ; Probe #57.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_57
  neg ebx
skip_neg_direction_57 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_1_byte_cmps_access PROC  ; Probe #58.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_58
  neg ebx
skip_neg_direction_58 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_cmps_access ENDP

ALIGN 16
asan_check_4_byte_cmps_access PROC  ; Probe #59.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_59
  neg ebx
skip_neg_direction_59 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_cmps_access ENDP

ALIGN 16
asan_check_2_byte_cmps_access PROC  ; Probe #60.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_60
  neg ebx
skip_neg_direction_60 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_cmps_access ENDP

ALIGN 16
asan_check_1_byte_cmps_access PROC  ; Probe #61.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_61
  neg ebx
skip_neg_direction_61 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_cmps_access ENDP

ALIGN 16
asan_check_repz_4_byte_lods_access PROC  ; Probe #62.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_62
  neg ebx
skip_neg_direction_62 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_lods_access ENDP

ALIGN 16
asan_check_repz_2_byte_lods_access PROC  ; Probe #63.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_63
  neg ebx
skip_neg_direction_63 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_lods_access ENDP

ALIGN 16
asan_check_repz_1_byte_lods_access PROC  ; Probe #64.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_64
  neg ebx
skip_neg_direction_64 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_lods_access ENDP

ALIGN 16
asan_check_4_byte_lods_access PROC  ; Probe #65.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_65
  neg ebx
skip_neg_direction_65 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_lods_access ENDP

ALIGN 16
asan_check_2_byte_lods_access PROC  ; Probe #66.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_66
  neg ebx
skip_neg_direction_66 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_lods_access ENDP

ALIGN 16
asan_check_1_byte_lods_access PROC  ; Probe #67.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_67
  neg ebx
skip_neg_direction_67 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 1
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 0
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_lods_access ENDP

ALIGN 16
asan_check_repz_4_byte_movs_access PROC  ; Probe #68.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_68
  neg ebx
skip_neg_direction_68 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_movs_access ENDP

ALIGN 16
asan_check_repz_2_byte_movs_access PROC  ; Probe #69.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_69
  neg ebx
skip_neg_direction_69 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_movs_access ENDP

ALIGN 16
asan_check_repz_1_byte_movs_access PROC  ; Probe #70.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_70
  neg ebx
skip_neg_direction_70 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_movs_access ENDP

ALIGN 16
asan_check_4_byte_movs_access PROC  ; Probe #71.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_71
  neg ebx
skip_neg_direction_71 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_movs_access ENDP

ALIGN 16
asan_check_2_byte_movs_access PROC  ; Probe #72.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_72
  neg ebx
skip_neg_direction_72 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_movs_access ENDP

ALIGN 16
asan_check_1_byte_movs_access PROC  ; Probe #73.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_73
  neg ebx
skip_neg_direction_73 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 0
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_movs_access ENDP

ALIGN 16
asan_check_repz_4_byte_stos_access PROC  ; Probe #74.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_74
  neg ebx
skip_neg_direction_74 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_4_byte_stos_access ENDP

ALIGN 16
asan_check_repz_2_byte_stos_access PROC  ; Probe #75.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_75
  neg ebx
skip_neg_direction_75 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_2_byte_stos_access ENDP

ALIGN 16
asan_check_repz_1_byte_stos_access PROC  ; Probe #76.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_76
  neg ebx
skip_neg_direction_76 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push ecx
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_repz_1_byte_stos_access ENDP

ALIGN 16
asan_check_4_byte_stos_access PROC  ; Probe #77.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 4
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_77
  neg ebx
skip_neg_direction_77 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 4
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_4_byte_stos_access ENDP

ALIGN 16
asan_check_2_byte_stos_access PROC  ; Probe #78.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 2
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_78
  neg ebx
skip_neg_direction_78 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 2
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_2_byte_stos_access ENDP

ALIGN 16
asan_check_1_byte_stos_access PROC  ; Probe #79.
  ; Prologue, save context.
  pushfd
  pushad
  ; Fix the original value of ESP in the Asan registers context.
  ; Removing 8 bytes (e.g.EFLAGS / EIP was on stack).
  add DWORD PTR[esp + 12], 8
  ; Setup increment in EBX (depends on direction flag in EFLAGS).
  mov ebx, 1
  pushfd
  pop eax
  test eax, 400h
  jz skip_neg_direction_79
  neg ebx
skip_neg_direction_79 LABEL NEAR
  ; By standard calling convention, direction flag must be forward.
  cld
  ; Push ARG(context), the Asan registers context.
  push esp
  ; Push ARG(compare), shortcut when memory contents differ.
  push 0
  ; Push ARG(increment), increment for EDI/EDI.
  push ebx
  ; Push ARG(access_size), the access size.
  push 1
  ; Push ARG(length), the number of memory accesses.
  push 1
  ; Push ARG(src_access_mode), source access type.
  push 2
  ; Push ARG(src), the source pointer.
  push esi
  ; Push ARG(dst_access_mode), destination access type.
  push 1
  ; Push ARG(dst), the destination pointer.
  push edi
  ; Call the generic check strings function.
  call asan_check_strings_memory_accesses
  add esp, 36
  ; Epilogue, restore context.
  popad
  popfd
  ret
asan_check_1_byte_stos_access ENDP

.probes ENDS

; Start writing to the read-only .rdata segment.
.rdata SEGMENT PAGE PUBLIC READ 'DATA'

; This is a null-terminated table of pointers to all shadow memory references.
; This is emitted so that the shadow memory pointer may be rewritten at
; runtime by the dynamic RTL.
ALIGN 4
asan_shadow_references LABEL FAR
  DWORD shadow_reference_0 - 4
  DWORD shadow_reference_1 - 4
  DWORD shadow_reference_2 - 4
  DWORD shadow_reference_3 - 4
  DWORD shadow_reference_4 - 4
  DWORD shadow_reference_5 - 4
  DWORD shadow_reference_6 - 4
  DWORD shadow_reference_7 - 4
  DWORD shadow_reference_8 - 4
  DWORD shadow_reference_9 - 4
  DWORD shadow_reference_10 - 4
  DWORD shadow_reference_11 - 4
  DWORD shadow_reference_12 - 4
  DWORD shadow_reference_13 - 4
  DWORD shadow_reference_14 - 4
  DWORD shadow_reference_15 - 4
  DWORD shadow_reference_16 - 4
  DWORD shadow_reference_17 - 4
  DWORD shadow_reference_18 - 4
  DWORD shadow_reference_19 - 4
  DWORD shadow_reference_20 - 4
  DWORD shadow_reference_21 - 4
  DWORD shadow_reference_22 - 4
  DWORD shadow_reference_23 - 4
  DWORD shadow_reference_24 - 4
  DWORD shadow_reference_25 - 4
  DWORD shadow_reference_26 - 4
  DWORD shadow_reference_27 - 4
  DWORD shadow_reference_28 - 4
  DWORD shadow_reference_29 - 4
  DWORD shadow_reference_30 - 4
  DWORD shadow_reference_31 - 4
  DWORD shadow_reference_32 - 4
  DWORD shadow_reference_33 - 4
  DWORD shadow_reference_34 - 4
  DWORD shadow_reference_35 - 4
  DWORD shadow_reference_36 - 4
  DWORD shadow_reference_37 - 4
  DWORD shadow_reference_38 - 4
  DWORD shadow_reference_39 - 4
  DWORD shadow_reference_40 - 4
  DWORD shadow_reference_41 - 4
  DWORD shadow_reference_42 - 4
  DWORD shadow_reference_43 - 4
  DWORD shadow_reference_44 - 4
  DWORD shadow_reference_45 - 4
  DWORD shadow_reference_46 - 4
  DWORD shadow_reference_47 - 4
  DWORD shadow_reference_48 - 4
  DWORD shadow_reference_49 - 4
  DWORD shadow_reference_50 - 4
  DWORD shadow_reference_51 - 4
  DWORD shadow_reference_52 - 4
  DWORD shadow_reference_53 - 4
  DWORD shadow_reference_54 - 4
  DWORD shadow_reference_55 - 4
  DWORD 0

.rdata ENDS

END
